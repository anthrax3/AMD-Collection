<!doctype html>
<head>
	<title>Iterator AMD Module: Test Suite</title>

	<link rel="stylesheet" href="lib/qunit.css" type="text/css" media="screen">
	<script src="lib/qunit.js"></script>
	<script src="lib/sinon.js"></script>
	<script src="lib/require.js"></script>
	<script src="lib/testing.js"></script>

	<script>
		require([ '../src/iterator' ], function( Iterator ) {
			QUnit.config.testTimeout = 2000;

			var itemFactory = function( count ){
				var items = [],
				id;

				while ( count-- ){
					id = Math.floor( Math.random() * (1000 - 0 + 1) + 0 );
					items.push({
						id: id,
						title: 'Item ' + id,
						greet: function(){
							return this.title;
						}
					});
				}

				return items;
			};

			var createAddOverride = function( keyPrefix, ctx ){
				
				return function( items ){
					var item;
					for ( var i = 0, len = items.length; i < len; i += 1 ){
						item = items[ i ];
						ctx.collection[ 'key-' + i ] = item;
						Iterator.prototype.add.call( ctx, item );
					}
					return this;
				};
			};

			module("Iterator", {
				setup: function() {
					strictEqual( typeof l, 'undefined', 'iterator instance is undefined, test is using a clean instance' );
				}
			});

			test( 'environment', function(){
				notStrictEqual( window.location.protocol, 'file:', 'Not running tests under the "file:" protocol' );
			});

			test( 'module has the correct methods & properties', function(){
				var l,
				expected = {
					'key': 'undefined',
					'has': 'function',
					'hasIndex': 'function',
					'hasKey': 'function',
					'hasNext': 'function',
					'hasPrev': 'function',
					'isFirst': 'function',
					'isLast': 'function',
					'isEmpty': 'function',
					'get': 'function',
					'getNext': 'function',
					'getPrev': 'function',
					'current': 'function',
					'next': 'function',
					'prev': 'function',
					'first': 'function',
					'last': 'function',
					'indexOf': 'function',
					'indexOfKey': 'function',
					'getKeyForIndex': 'function',
					'getKeyForItem': 'function',
					'setIndex': 'function',
					'add': 'function',
					'remove': 'function',
					'update': 'function',
					'replace': 'function',
					'empty': 'function',
					'toJSON': 'function',
					'filter': 'function',
					'each': 'function',
					'collection': 'object',
					'index': 'number',
					'length': 'number',
					'isLooping': 'boolean'
				};

				l = Iterator( [ 'fe', 'fi', 'fo', 'fum' ] );

				expect( 2 + Object.keys( expected ).length );

				strictEqual( Object.keys( Iterator.prototype ).length + Object.keys( l ).length, Object.keys( expected ).length, 'all ' + Object.keys( expected ).length + ' methods have been identified' );

				for ( var prop in expected ) {
					strictEqual( typeof l[ prop ], expected[ prop ], 'module includes the "' + prop + '" method / property' );
				}
			});

			test( 'constructor - new Iterator()', function(){
				strictEqual( typeof Iterator, 'function', 'Iterator constructor is available' );

				var l = Iterator( [ 1, 2, 3, 4, 5 ] );

				strictEqual( l.length, 5, 'passing an array to constructor creates a collection with the correct number of items' );
				strictEqual( typeof l.collection, 'object', 'collection is available within iterator instance' );
				strictEqual( l.get( 2 ), 3, 'collection contents are correct' );

				l = new Iterator();
				strictEqual( l.length, 0, 'calling constructor without any arguments creates a collection without any items' );

				l = Iterator( 'q' );
				strictEqual( l.length, 1, 'passing a single, non-array argument to constructor creates a collection with one item' );
				strictEqual( l.get( 0 ), 'q', 'collection contents are correct' );

				l = new Iterator( 'a', 'b', 'c', 'd' );
				strictEqual( l.length, 4, 'passing multiple arguments to constructor creates a collection with the correct number of items' );
				strictEqual( l.get( 2 ), 'c', 'collection contents are correct' );

				l = Iterator({ a:1, b:2, c: 3 });
				strictEqual( l.length, 1, 'passing a single object to constructor creates a collection with one item' );
				strictEqual( l.get( 0 ).b, 2, 'collection contents are correct' );

				l = new Iterator({ a:1, b:2, c: 3 }, { e:4, f:5, g:6 });
				strictEqual( l.length, 2, 'passing two objects to constructor creates a collection with two items' );
				strictEqual( l.get( 1 ).f, 5, 'collection contents are correct' );

				l = Iterator( { a:1, b:2 }, 10, 11, 12, 'a', 'b', 'c')
				strictEqual( l.length, 7, 'passing arguments of multiple types to constructor creates a collection with the correct number of items' );
				ok(
					l.get( 0 ).b === 2 &&
					l.get( 2 ) === 11 &&
					l.get( 4 ) === 'a',
					'collection contents are correct'
				);

				l = new Iterator([ 1, 2, 3 ], [ 'a', 'b', 'c' ] );
				strictEqual( l.length, 2, 'passing two arrays to constructor creates a collection with two items' );
				strictEqual( l.get( 1 )[ 1 ], 'b', 'collection contents are correct' );

				l = new Iterator( [ { id: 1, name: 'one' }, { id: 2, name: 'two' } ], { useLookupKey: 'id' } );
				strictEqual( l.key, 'id', 'passing in a config object sets the iterator\'s lookup key' );
				strictEqual( l.length, 2, 'passing an array as the 1st argument before config object creates collection with correct number of items' );
				strictEqual( l.get( 'id1' ).name, 'one', 'can retrieve item by key' );

				l = new Iterator( { id: 1, name: 'one' }, { id: 2, name: 'two' }, { useLookupKey: 'id' } );
				strictEqual( l.key, 'id', 'passing in a config object sets the iterator\'s lookup key' );
				strictEqual( l.length, 2, 'passing a series of object arguments before config object creates collection with correct number of items' );
				strictEqual( l.get( 'id1' ).name, 'one', 'can retrieve item by key' );
			});

			test( 'property - .index', function(){
				var l = Iterator( [ 1, 2, 3, 4, 5 ] );

				strictEqual( l.index, 0, 'initial .index value is correct' );
				l.last();
				strictEqual( l.index, 4, '.index value is correct after calling .last()' );
				l.first();
				strictEqual( l.index, 0, '.index value is correct after calling .first()' );
				l.next();
				strictEqual( l.index, 1, '.index value is correct after calling .next()' );
				l.prev();
				strictEqual( l.index, 0, '.index value is correct after calling .prev()' );
				l.setIndex( 3 );
				strictEqual( l.index, 3, '.index value is correct after calling .setIndex()' );
				l.get( 3 );
				strictEqual( l.index, 3, '.index value should not change after calling .get()' );
			});

			test( 'property - .length', function(){
				var l;

				l = Iterator( [ 1, 2, 3, 4, 5 ] );

				strictEqual( l.length, 5, 'newly initialized iterator instance has correct length' );
				l.add( [ 6 ] );
				strictEqual( l.length, 6, 'instance has correct length after adding an item to the collection' );
				l.remove( 0 );
				strictEqual( l.length, 5, 'instance has correct length after removing item to the collection' );
				l.add( [ 7, 8, 9 ] );
				strictEqual( l.length, 8, 'instance has correct length after adding multiple items to the collection' );
			});

			test( 'property - .isLooping', function() {
				var l = Iterator( [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09' ] );

				l.isLooping = true;

				strictEqual( l.current(), '00', 'current item is correct' );
				strictEqual( l.getNext(), '01', '.getNext() returns correct item' );
				strictEqual( l.next(), '01', '.next() returns correct item' );
				strictEqual( l.last(), '09', 'last item is correct' );
				strictEqual( l.getNext(), '00', 'requesting .getNext() at end of collection returns 1st item' );
				strictEqual( l.next(), '00', 'requesting .next() at end of collection returns 1st item and increments the collection\'s idx' );
				strictEqual( l.current(), '00', 'current item is correct' );
				strictEqual( l.next(), '01', '.next() returns correct item' );
				strictEqual( l.setIndex(3).prev(), '02', 'setting an idx and requesting .prev() returns correct item' );
				strictEqual( l.first(), '00', 'first item is correct' );
				strictEqual( l.getPrev(), '09', 'requesting .getPrev() at start of collection returns last item' );
				strictEqual( l.prev(), '09', 'requesting .prev() at start of collection returns last item and increments the collection\'s idx' );
				strictEqual( l.current(), '09', 'current item is correct' );
				strictEqual( l.getPrev(), '08', '.getPrev() returns correct item' );
				strictEqual( l.prev(), '08', '.prev() returns correct item' );

				l = Iterator( [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09' ] );
				l.isLooping = true;

				strictEqual( l.getPrev(), '09', 'requsting .getPrev() after initializing a collection returns correct item' );
				strictEqual( l.prev(), '09', 'requsting .prev() after initializing a collection returns correct item and increments the collection\'s idx' );
				strictEqual( l.current(), '09', 'current item is correct' );
			});

			test( 'method - .has()', function(){
				var l, items;

				items = [ 0, 1, null, false, {}, [], function(){}, new Date(), /.+/gi, 'last' ];
				l = Iterator();
				l.add = createAddOverride( 'key-', l );
				l.add( items );

				for ( var j = 0, length = items.length; j < length; j += 1 ){
					strictEqual( l.has( 'key-' + j ), true, 'can check for item by key - .has( "key-' + j + '" )' );
				}
				strictEqual( l.hasKey( 'key-' + 666 ), false, 'does not have nonexistant key - .has( "key-666" )' );

				strictEqual( l.has( 0 ), true, 'can check for zero index - .has( 0 )' );
				strictEqual( l.has( 2 ), true, 'can check for 2nd index - .has( 2 )' );
				strictEqual( l.has( 4 ), true, 'does not have 4th idx - .has( 4 )' );
				strictEqual( l.has( 7 ), true, 'can check for 7th index - .has( 7 )' );
				strictEqual( l.has( 666 ), false, 'does not have nonexistant index - .has( 666 )' );
			});

			test( 'method - .hasIndex()', function(){
				var l;

				l = Iterator( [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 ] );

				strictEqual( l.hasIndex( 0 ), true, 'has zero idx - .has( 0 )' );
				strictEqual( l.hasIndex( 7 ), true, 'has 7th idx - .has( 7 )' );
				strictEqual( l.hasIndex( 15 ), false, 'does not have 15th idx - .has( 15 )' );
			});

			test( 'method - .hasKey()', function(){
				var l, items;

				items = [ 0, 1, null, false, {}, [], function(){}, new Date(), /.+/gi, 'last' ];
				l = Iterator();
				l.add = createAddOverride( 'key-', l );
				l.add( items );

				for ( var j = 0, length = items.length; j < length; j += 1 ){
					strictEqual( l.hasKey( 'key-' + 1 ), true, 'has key' );
				}
				strictEqual( l.hasKey( 'key-' + 666 ), false, 'does not have key' );
			});

			test( 'method - .hasNext()', function(){
				var l;

				l = Iterator( [ 1, 2, 3, 4, 5 ] );

				strictEqual( l.hasNext(), true, 'newly initialized iterator instance has next item' );
				l.last();
				strictEqual( l.hasNext(), false, 'next item is not available when current item is last' );
				l.setIndex( 3 );
				strictEqual( l.hasNext(), true, 'next item is available when current item is in the middle of the collection' );
				l.first();
				strictEqual( l.hasNext(), true, 'next item is available when current item is first' );
			});

			test( 'method - .hasPrev()', function(){
				var l;

				l = Iterator( [ 1, 2, 3, 4, 5 ] );

				strictEqual( l.hasPrev(), false, 'previous item is not available when using a newly initialized iterator instance' );
				l.last();
				strictEqual( l.hasPrev(), true, 'previous item is available when current item is last' );
				l.setIndex( 3 );
				strictEqual( l.hasPrev(), true, 'previous item is available when current item is in the middle of the collection' );
				l.first();
				strictEqual( l.hasPrev(), false, 'previous item is not available when current item is first' );
			});

			test( 'method - .isFirst()', function(){
				var l;

				l = Iterator( [ 1, 2, 3, 4, 5 ] );

				strictEqual( l.isFirst(), true, 'isFirst() returns true when called on a newly initialized iterator instance' );
				l.last();
				strictEqual( l.isFirst(), false, 'isFirst() returns false when current item is last item' );
				l.setIndex( 3 );
				strictEqual( l.isFirst(), false, 'isFirst() returns false when current item is in the middle of the collection' );
				l.first();
				strictEqual( l.isFirst(), true, 'isFirst() returns true when current item is first' );
				l.last();
				strictEqual( l.isFirst( 0 ), true, 'isFirst( 0 ) returns true' );
				strictEqual( l.isFirst( 3 ), false, 'isFirst( 3 ) returns false' );

				l = new Iterator( [ { id: 1, name: 'one' }, { id: 2, name: 'two' }, { id: 3, name: 'three' } ], { useLookupKey: 'id' } );

				strictEqual( l.isFirst(), true, 'isFirst() returns true when called on a newly initialized iterator instance which uses key-based lookup' );
				l.last();
				strictEqual( l.isFirst(), false, 'isFirst() returns false when current item is last item' );
				l.setIndex( 1 );
				strictEqual( l.isFirst(), false, 'isFirst() returns false when current item is in the middle of the collection' );
				l.first();
				strictEqual( l.isFirst(), true, 'isFirst() returns true when current item is first' );
				l.last();
				strictEqual( l.isFirst( 0 ), true, 'isFirst( 0 ) returns true' );
				strictEqual( l.isFirst( 3 ), false, 'isFirst( 3 ) returns false' );
				strictEqual( l.isFirst( 'id1' ), true, 'isFirst( \'id1\' ) returns true' );
				strictEqual( l.isFirst( 'id2' ), false, 'isFirst( \'id2\' ) returns false' );
				strictEqual( l.isFirst( 'id3' ), false, 'isFirst( \'id3\' ) returns false' );
			});

			test( 'method - .isLast()', function(){
				var l;

				l = Iterator( [ 1, 2, 3, 4, 5 ] );

				strictEqual( l.isLast(), false, 'isLast() returns false when called on a newly initialized iterator instance' );
				l.last();
				strictEqual( l.isLast(), true, 'isLast() returns true when current item is last item' );
				l.setIndex( 3 );
				strictEqual( l.isLast(), false, 'isLast() returns false when current item is in the middle of the collection' );
				l.first();
				strictEqual( l.isLast(), false, 'isLast() returns false when current item is first' );
				strictEqual( l.isLast( 0 ), false, 'isFirst( 0 ) returns false' );
				strictEqual( l.isLast( 3 ), false, 'isFirst( 3 ) returns false' );
				strictEqual( l.isLast( l.length - 1 ), true, 'isFirst( l.length -1 ) returns true' );

				l = new Iterator( [ { id: 1, name: 'one' }, { id: 2, name: 'two' }, { id: 3, name: 'three' } ], { useLookupKey: 'id' } );

				strictEqual( l.isLast(), false, 'isLast() returns false when called on a newly initialized iterator instance which uses key-based lookup' );
				l.last();
				strictEqual( l.isLast(), true, 'isLast() returns true when current item is last item' );
				l.setIndex( 1 );
				strictEqual( l.isLast(), false, 'isLast() returns false when current item is in the middle of the collection' );
				l.first();
				strictEqual( l.isLast(), false, 'isLast() returns false when current item is first' );
				strictEqual( l.isLast( 0 ), false, 'isFirst( 0 ) returns false' );
				strictEqual( l.isLast( 3 ), false, 'isFirst( 3 ) returns false' );
				strictEqual( l.isLast( l.length - 1 ), true, 'isFirst( l.length -1 ) returns true' );
				strictEqual( l.isLast( 'id1' ), false, 'isLast( \'id1\' ) returns false' );
				strictEqual( l.isLast( 'id2' ), false, 'isLast( \'id2\' ) returns false' );
				strictEqual( l.isLast( 'id3' ), true, 'isLast( \'id3\' ) returns true' );
			});

			test( 'method - .isEmpty()', function(){
				var l, x;

				l = Iterator();

				strictEqual( l.isEmpty(), true, 'collection is empty' );
				strictEqual( l.length, 0, 'collection length is zero' );
				strictEqual( l.index, 0, 'collection index is zero' );

				x = new Iterator( [ 1, 2, 3, 4, 5 ] );

				strictEqual( x.isEmpty(), false, 'collection is not empty' );
				strictEqual( x.length, 5, 'collection length is five' );
				strictEqual( x.index, 0, 'collection index is zero' );
			});


			test( 'method - .get()', function(){
				var l;

				l = Iterator( [ 1, 2, 3, 4, 5 ] );

				strictEqual( l.get( 0 ), 1, 'got 1st item' );
				strictEqual( l.get( 3 ), 4, 'got 3rd item' );
				strictEqual( typeof l.get( 999 ), 'undefined', 'undefined returned when getting unavailable idx' );
			});

			test( 'method - .getNext()', function(){
				var l;

				l = Iterator( [ 1, 2, 3, 4, 5 ] );
				l.setIndex( 2 );

				strictEqual( l.getNext(), 4, 'got next item' );
				strictEqual( l.index, 2, 'calling .getNext() does not increment idx' );

				l.last();
				strictEqual( typeof l.getNext(), 'undefined', 'undefined returned when next item is unavailable' );
			});

			test( 'method - .getPrev()', function(){
				var l;

				l = Iterator( [ 1, 2, 3, 4, 5 ] );
				l.setIndex( 3 );

				strictEqual( l.getPrev(), 3, 'got previous item' );
				strictEqual( l.index, 3, 'calling .getNext() does not increment idx' );

				l.first();
				strictEqual( typeof l.getPrev(), 'undefined', 'undefined returned when previous item is unavailable' );
			});

			test( 'method - .current()', function(){
				var l;

				l = Iterator( [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ] );

				strictEqual( l.current(), 1, 'initial .current() value is correct' );
				l.next();
				strictEqual( l.current(), 2, 'after requesting .next(), .current() value is correct' );
				l.last();
				strictEqual( l.current(), 13, 'after requesting .last(), .current() value is correct' );
				l.first();
				strictEqual( l.current(), 1, 'after requesting .first(), .current() value is correct' );
				l.setIndex( 6 );
				strictEqual( l.current(), 7, 'after setting a arbitrary index via .setIndex(), .current() value is correct' );
				l.isLooping = true;
				l.last();
				l.next();
				strictEqual( l.current(), 1, 'when looping, .current() value is correct after calling .next() while on last item' );
				l.first();
				l.prev();
				strictEqual( l.current(), 13, 'when looping, .current() value is correct after calling .prev() while on first item' );
			});

			test( 'method - .next()', function(){
				var l;

				l = Iterator( [ 1, 2, 3, 4, 5 ] );

				strictEqual( l.current(), 1, 'current item is correct [' + l.current() + ']' );
				while ( l.hasNext() ){
					strictEqual( typeof l.next(), 'number', 'able to retreive next item [' + l.current() + ']' );
				}
				strictEqual( l.isLast(), true, 'current item is last item' );
				strictEqual( l.next(), null, '.next() returns null when current item is last item' );
			});

			test( 'method - .prev()', function(){
				var l;

				l = Iterator( [ 1, 2, 3, 4, 5 ] );
				l.last();

				strictEqual( l.current(), 5, 'current item is correct [' + l.current() + ']' );
				while ( l.hasPrev() ){
					strictEqual( typeof l.prev(), 'number', 'able to retreive prev item [' + l.current() + ']' );
				}
				strictEqual( l.isFirst(), true, 'current item is first item' );
				strictEqual( l.prev(), null, '.prev() returns null when current item is first item' );
			});

			test( 'method - .first()', function(){
				var l;

				l = Iterator( [ 1, 2, 3, 4, 5 ] );

				l.last();
				strictEqual( l.isLast(), true, 'current item is last item' );
				l.first();
				strictEqual( l.isFirst(), true, 'current item is first item' );
			});

			test( 'method - .last()', function(){
				var l;

				l = Iterator( [ 1, 2, 3, 4, 5 ] );

				strictEqual( l.isFirst(), true, 'current item is first item' );
				l.last();
				strictEqual( l.isLast(), true, 'current item is last item' );
			});

			test( 'method - .indexOf()', function(){
				var l,
				first = { first: 'first' },
				second = { second: 'second' },
				third = { third: 'third' };

				l = Iterator( [ 0, 'a', 'b', 'c', 'd', 'e', 'f' ] );

				strictEqual( l.indexOf( 0 ), 0, 'first item has correct index' );
				strictEqual( l.indexOf( 'f' ), 6, 'last item has correct index' );
				strictEqual( l.indexOf( 'd', 4 ), 4, 'item\'s index is correct when providing "fromIdx" argument' );

				l = new Iterator([ first, second, third ]);

				strictEqual( l.indexOf( first ), 0, 'using a collection of objects, first item has correct index' );
				strictEqual( l.indexOf( third ), 2, 'using a collection of objects, last item has correct index' );
				strictEqual( l.indexOf( second, 1 ), 1, 'using a collection of objects, item\'s index is correct when providing "fromIdx" argument' );
			});

			test( 'method - .indexOfKey()', function(){
				var l, items, undef;

				items = [ 'a', 'b', 'c', 'd', 'e' ];
				l = Iterator();
				l.add = createAddOverride( 'key-', l );

				l.add( items );

				strictEqual( l.indexOfKey( 'key-0' ), 0, 'returned correct index for first item - .indexOfKey( "key-0" )' );
				strictEqual( l.indexOfKey( 'key-0', 1 ), -1, 'returned -1 (not found) for first item when starting from later index - .indexOfKey( "key-0", 1 )' );
				strictEqual( l.indexOfKey( 'key-3' ), 3, 'returned correct index for third item - .indexOfKey( "key-3" )' );
				strictEqual( l.indexOfKey( 'key-3', 2 ), 3, 'returned correct index for third item when starting from later index - .indexOfKey( "key-3", 2 )' );
			});

			test( 'method - .getKeyForIndex()', function(){
				var l, undef;

				l = Iterator( [ 'a', 'b', 'c' ] );

				strictEqual( l.getKeyForIndex( 1 ), undef, 'undefined is returned when collection does not use key-based lookup' );

				l = new Iterator( [ { id: 1, name: 'one' }, { id: 2, name: 'two' }, { id: 3, name: 'three' } ], { useLookupKey: 'id' } );

				strictEqual( l.getKeyForIndex( 1 ), 'id2', 'lookup key is returned when collection uses key-based lookup' );
			});

			test( 'method - .getKeyForItem()', function(){
				var l, undef;

				l = Iterator( [ 'a', 'b', 'c' ] );

				raises( function(){ l.getKeyForItem( 'a' ) }, 'getting a key without providing an item object throws an error' );

				l = new Iterator( [ { id: 1, name: 'one' }, { id: 2, name: 'two' }, { id: 3, name: 'three' } ], { useLookupKey: 'id' } );

				strictEqual( l.getKeyForItem( { id: 4, name: 'four' } ), 'id4', 'lookup key is returned for item when collection uses key-based lookup' );
				strictEqual( l.getKeyForItem( { not: 'a', supported: 'object' } ), undef, 'undefined is returned when item does not have key' );
			});

			test( 'method - .setIndex()', function(){
				var l;

				l = Iterator( [ 1, 2, 3, 4, 5 ] );

				strictEqual( l.first(), 1, 'newly initialized iterator instance has the correct first item' );
				strictEqual( l.setIndex( 3 ).current(), 4, 'current item is correct after setting new index' );
				raises( function(){ l.setIndex( 666 ) }, 'setting index to an unknown / unavailable item throws an error' );
			});

			test( 'method - .toJSON()', function(){
				var l, expected;

				expected = '[{"id":1,"name":"foo"},{"id":2,"name":"bar"},{"id":3,"name":"baz"},{"id":4,"name":"qux"},{"id":5,"name":"bla"}]';

				l = new Iterator([
					{ id: 1, name: 'foo', fn: function(){} },
					{ id: 2, name: 'bar', fn: function(){} },
					{ id: 3, name: 'baz', fn: function(){} },
					{ id: 4, name: 'qux', fn: function(){} },
					{ id: 5, name: 'bla', fn: function(){} }
				]);

				deepEqual( JSON.stringify( l ), expected, 'JSON.stringify() returns correct representation of collection' );
			});

			test( 'method - .add()', function(){
				var l;

				l = Iterator( [ 'matt', 'mirande' ] );

				strictEqual( l.length, 2, 'newly initialized iterator instance has correct length' );
				l.add( [ 'edward' ], 1 );
				strictEqual( l.get( 1 ), 'edward', 'item added at the correct index' );
				strictEqual( l.length, 3, 'updated collection has the correct length' );
				strictEqual( l.collection.join( ' ' ), 'matt edward mirande', 'contents of the collection are correct' );
				l.add( [ 'rulez' ] );
				strictEqual( l.last(), 'rulez', 'new item added to end of collection by default' );
				strictEqual( l.collection.join( ' ' ), 'matt edward mirande rulez', 'contents of the collection are correct' );
				l.add( [ '!', '!', '!', '!' ] );
				strictEqual( l.collection.join( ' ' ), 'matt edward mirande rulez ! ! ! !', 'contents of the collection are correct after adding multiple items' );

				l = Iterator();
				strictEqual( l.length, 0, 'iterator instance was reset' );
				l.add( 'hello there!' );
				strictEqual( l.length, 1, 'passing a single, non-array argument to .add() adds an item to the collection' );
				strictEqual( l.get( 0 ), 'hello there!', 'collection contents are correct' );
				l.add({ a:1, b:2, c: 3 });
				strictEqual( l.length, 2, 'passing a single object to .add() adds an object to the collection' );
				strictEqual( l.get( 1 ).b, 2, 'collection contents are correct' );

				l = new Iterator( [ { id: 1, name: 'one' }, { id: 2, name: 'two' }, { id: 3, name: 'three' } ], { useLookupKey: 'id' } );
				strictEqual( l.length, 3, 'key-based iterator instance has correct number of items' );
				l.add( { id: 1.5, name: 'one point five' }, 'id2' );
				strictEqual( l.length, 4, 'key-based iterator instance has correct number of items after adding an item by a given key' );
				strictEqual( l.get( 1 ).name, 'one point five', 'new item is added at the correct index' );
			});

			test( 'method - .remove()', function(){
				var l, undef;

				l = Iterator( [ 'a', 'b', 'c', 'd', 'e' ] );

				strictEqual( l.length, 5, 'newly initialized iterator instance has correct length' );
				l.remove( 1 )
				strictEqual( l.collection.join( '' ), 'acde', 'target item removed properly' );

				l = new Iterator( [ { id: 1, name: 'one' }, { id: 2, name: 'two' }, { id: 3, name: 'three' } ], { useLookupKey: 'id' } );

				strictEqual( l.length, 3, 'newly initialized iterator instance has correct length when using key-based lookup' );
				l.remove( 'id2' );
				strictEqual( l.get( 'id2' ), undef, 'target item removed properly when removing by key' );
				strictEqual( l.length, 2, 'iterator has correct length after removing an item by key' );
				deepEqual( l.collection, [ { id: 1, name: 'one' }, { id: 3, name: 'three' } ], 'iterator collection is correct' );
				l.remove( 0 );
				strictEqual( l.get( 'id1' ), undef, 'target item removed properly when removing by index' );
				strictEqual( l.length, 1, 'iterator has correct length after removing an item by index' );
				deepEqual( l.collection, [ { id: 3, name: 'three' } ], 'iterator collection is correct' );
				deepEqual( l.remove( 9999 ), l, 'removing non-existent key does not throw' );
				deepEqual( l.remove( 'id9999' ), l, 'removing non-existent index does not throw' );
			});

			test( 'method - .update()', function(){
				var l, expectedItem, undef;

				l = Iterator( [ 'a', 'b', 'c' ] );

				l.update(  0, 'b' );
				l.update(  2, 'd' );
				l.update(  1, 'a' );

				strictEqual( l.collection.join( '' ), 'bad', 'target items updated properly' );
				raises( function(){ l.update( 666, 'nope' ) }, 'updating an unknown index throws an error' );

				expectedItem = { id: 2.5, name: 'two point five' };
				l = new Iterator( [ { id: 1, name: 'one' }, { id: 2, name: 'two' }, { id: 3, name: 'three' } ], { useLookupKey: 'id' } );
				l.update( 'id3', expectedItem );

				strictEqual( l.length, 3, 'iterator has correct length after updating an item by key' );
				deepEqual( l.get( 2 ), expectedItem, 'updated item uses the correct index when updating by key' );
				deepEqual( l.get( 'id2.5' ), expectedItem, 'updated item uses the correct key when updating by key' );
				deepEqual( l.get( 'id3' ), undef, 'key for original item is no longer available when updating by key' );
			});

			test( 'method - .replace()', function(){
				var l;

				l = Iterator( [ 'a', 'b', 'c', 'd', 'e', 'f', 'g' ] );

				l.replace( 2, [ 'x', 'x', 'x' ] );

				strictEqual( l.collection.join( '' ), 'abxxxfg', 'target items replaced' );
				raises( function(){ l.replace( 666, [ 'nope' ] ) }, 'replacing an unknown index throws an error' );
			});

			test( 'method - .empty()', function(){
				var l;

				l = Iterator( [ 'a', 'b', 'c', 'd', 'e', 'f', 'g' ] );

				l.empty();

				ok( l.isEmpty(), 'collection is empty' );
				strictEqual( l.length, 0, 'collection length is 0' );
				ok( testing.utils.isArray( l.collection ), 'collection is an array' );
				deepEqual( l.empty(), l, 'method is chainable' );
			});

			test( 'method - .filter()', function(){
				var l,
				newL;

				l = Iterator( [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30 ] );

				strictEqual( l.length, 30, 'newly initialized iterator instance is the correct length' );

				newL = l.filter( function( item ){ return item >= 10 && item < 20; } );

				strictEqual( newL.length, 10, 'filtered instance is the correct length' );
				strictEqual( newL instanceof Iterator, true, 'filtered instance is a child of Iterator' );
				strictEqual( newL.current(), 10, 'filtered instance has correct current item' );
			});

			test( 'method - .each()', function(){
				var l = Iterator( [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ] );
				var fn = function( item, index ){
					strictEqual( this.toExponential(), item + 'e+0', 'calling .each() without a context argument sets context to collection item' );
				};
				var myObj = {
					name: 'myObj',
					test: function( item, index ){
						strictEqual( l.get( index ), item, 'callback receives the correct item' );
						strictEqual( l.indexOf( item ), index, 'callback receives the correct index' );
						strictEqual( this.name, 'myObj', 'callback uses correct context when calling .each() with a context argument' );
					}
				};

				raises( function(){ l.each( 'nope' ) }, 'calling .each() without an argument type of "function" throws an error' );

				l.each( myObj.test, myObj );
				l.each( fn );
				expect( 38 );
			});

			test( 'bugfix - can iteratively remove all collection items', function(){
				var l = new Iterator( itemFactory( 10 ) );

				l.isLooping = true;
				while ( l.length ){
					l.next();
					l.remove( l.index );
				}

				strictEqual( l.length, 0, 'collection length is zero' );
				strictEqual( l.index, 0, 'collection index is zero' );
			});
		});
	</script>
</head>
<body>
	<h1 id="qunit-header">Iterator AMD Module: Test Suite</h1>
	<h2 id="qunit-banner"></h2>
	<div id="qunit-testrunner-toolbar"></div>
	<h2 id="qunit-userAgent"></h2>
	<ol id="qunit-tests"></ol>
</body>
</html>
